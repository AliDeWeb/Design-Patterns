# 🐦‍🔥 الگوهای طراحی در TypeScript - اصول و قواعد

### نوشته شده توسط علی مرادی [AliDeWeb](https://github.com/AliDeWeb)

### اصول برنامه‌نویسی شیءگرا (OOP):

1. **Encapsulation (کپسوله‌سازی)** – بسته‌بندی داده‌ها و متدها در یک کلاس و محدود کردن دسترسی مستقیم به برخی جزئیات.
2. **Abstraction (تجرید)** – پنهان‌سازی جزئیات پیچیده پیاده‌سازی و نمایش تنها قابلیت‌های ضروری.
3. **Inheritance (وراثت)** – امکان وراثت ویژگی‌ها و رفتارهای یک کلاس از کلاس دیگر برای ترویج استفاده مجدد از کد.
4. **Polymorphism (چندریختی)** – فعال‌سازی رفتار چندگانه کلاس‌ها به عنوان نمونه‌هایی از یک ابرکلاس مشترک، امکان بازنویسی
   متدها و رفتار پویا.

-----

### **اصول SOLID:**

1. **Single Responsibility Principle (SRP) - اصل مسئولیت واحد** – یک کلاس باید فقط یک دلیل برای تغییر داشته باشد، به این
   معنی که باید فقط یک مسئولیت داشته باشد.
2. **Open/Closed Principle (OCP) - اصل باز/بسته** – موجودیت‌های نرم‌افزاری باید برای توسعه باز باشند، اما برای تغییر
   بسته.
3. **Liskov Substitution Principle (LSP) - اصل جانشینی لیسکوف** – زیرگونه‌ها باید بتوانند به جای گونه‌های پایه خود
   جایگزین شوند، بدون اینکه صحت برنامه را تغییر دهند.
4. **Interface Segregation Principle (ISP) - اصل تفکیک رابط** – کلاینت‌ها نباید مجبور به وابستگی به رابط‌هایی شوند که از
   آن‌ها استفاده نمی‌کنند.
5. **Dependency Inversion Principle (DIP) - اصل وارونگی وابستگی** – ماژول‌های سطح بالا نباید به ماژول‌های سطح پایین
   وابسته باشند؛ هر دو باید به تجریدها وابسته باشند.

-----

### **سایر اصول مهم:**

علاوه بر SOLID، اصول طراحی کلیدی دیگر در OOP عبارتند از:

* **DRY (Don’t Repeat Yourself) - تکرار نکنید** – از تکرار اجتناب کنید و کد قابل استفاده مجدد را تجرید کنید.
* **KISS (Keep It Simple, Stupid) - ساده نگه‌دار، احمق\!** – کد را ساده نگه دارید و از پیچیدگی غیرضروری اجتناب کنید.
* **YAGNI (You Ain’t Gonna Need It) - بهش نیاز پیدا نخواهی کرد** – ویژگی‌ها را مگر در صورت نیاز مطلق، پیاده‌سازی نکنید.
* **Law of Demeter (LoD) - قانون دمتر** – اشیاء باید فقط با اشیاء نزدیک مرتبط تعامل داشته باشند تا وابستگی را کاهش دهند.

این اصول از قابلیت نگهداری، مقیاس‌پذیری و کد تمیز اطمینان می‌دهند.

## 📂 انواع الگوهای طراحی

الگوهای طراحی به سه دسته اصلی تقسیم می‌شوند:

### **1. الگوهای رفتاری (Behavioral Patterns)**

این الگوها بر ارتباط بین اشیاء و نحوه تعامل آن‌ها با یکدیگر تمرکز دارند.

* **Observer (ناظر)** – وابستگی یک به چند بین اشیاء را تعریف می‌کند، به طوری که وقتی یک شیء تغییر وضعیت می‌دهد، تمام
  وابسته‌های آن مطلع می‌شوند.
* **Strategy (راهبرد)** – به یک شیء اجازه می‌دهد تا رفتار خود را به صورت پویا با تغییر بین الگوریتم‌های مختلف تغییر دهد.
* **Command (فرمان)** – یک درخواست را به عنوان یک شیء کپسوله می‌کند، و امکان پارامتری‌سازی کلاینت‌ها، صف‌بندی درخواست‌ها
  و ثبت عملیات را فراهم می‌کند.

### **2. الگوهای ساختاری (Structural Patterns)**

این الگوها به ترکیب کلاس‌ها و اشیاء برای شکل‌دهی ساختارهای بزرگتر در عین انعطاف‌پذیری و کارآمدی آن‌ها می‌پردازند.

* **Adapter (مبدل)** – شکاف بین رابط‌های ناسازگار را پر می‌کند.
* **Decorator (تزئین‌کننده)** – به صورت پویا عملکرد یک شیء را بدون تغییر کد آن گسترش می‌دهد.
* **Facade (نما)** – یک رابط ساده‌شده برای یک زیرسیستم پیچیده ارائه می‌دهد.

### **3. الگوهای سازنده (Creational Patterns)**

این الگوها بر مکانیزم‌های ایجاد شیء برای افزایش انعطاف‌پذیری و استفاده مجدد تمرکز دارند.

* **Factory Method (متد کارخانه)** – یک رابط برای ایجاد اشیاء فراهم می‌کند اما به زیرکلاس‌ها اجازه می‌دهد نوع اشیاء
  ایجاد شده را تغییر دهند.
* **Singleton (تک‌نسخه)** – تضمین می‌کند که یک کلاس فقط یک نمونه داشته باشد و یک نقطه دسترسی سراسری به آن فراهم می‌کند.
* **Builder (سازنده)** – امکان ایجاد گام‌به‌گام اشیاء پیچیده را فراهم می‌کند، و خوانایی و قابلیت نگهداری را بهبود
  می‌بخشد.

## 📂 الگوها

| الگوی طراحی                                  | مستندات                                           |
|----------------------------------------------|---------------------------------------------------|
| **Memento (یادگار)**                         | [📜 README](01_Memento/README.md)                 |
| **State (حالت)**                             | [📜 README](02_State/README.md)                   |
| **Iterator (تکرارگر)**                       | [📜 README](03_Iterator/README.md)                |
| **Strategy (راهبرد)**                        | [📜 README](04_Strategy/README.md)                |
| **Template Method (متد قالب)**               | [📜 README](05_Template_Method/README.md)         |
| **Command (فرمان)**                          | [📜 README](06_Command/README.md)                 |
| **Observer (ناظر)**                          | [📜 README](07_Observer/README.md)                |
| **Mediator (میانجی)**                        | [📜 README](08_Mediator/README.md)                |
| **Chain Of Responsibility (زنجیره مسئولیت)** | [📜 README](09_Chain_Of_Responsibility/README.md) |
| **Visitor (بازدیدکننده)**                    | [📜 README](10_Visitor/README.md)                 |
| **Prototype (نمونه اولیه)**                  | [📜 README](11_Prototype/README.md)               |
| **Singleton (تک‌نسخه)**                      | [📜 README](12_Singleton/README.md)               |
| **Factory Method (متد کارخانه)**             | [📜 README](13_Factory_Method/README.md)          |
| **Abstract Factory (کارخانه انتزاعی)**       | [📜 README](14_Abstract_Factory/README.md)        |
| **Builder (سازنده)**                         | [📜 README](15_Builder/README.md)                 |
| **Composite (ترکیبی)**                       | [📜 README](16_Composite/README.md)               |
| **Adaptor (مبدل)**                           | [📜 README](17_Adaptor/README.md)                 |
| **Decorator (تزئین‌کننده)**                  | [📜 README](18_Decorator/README.md)               |
| **Facade (نما)**                             | [📜 README](19_Facade/README.md)                  |
| **Fly Weight (مگس‌وزن)**                     | [📜 README](20_Fly_Weight/README.md)              |
| **Bridge (پل)**                              | [📜 README](21_Bridge/README.md)                  |
| **Proxy (نماینده)**                          | [📜 README](22_Proxy/README.md)                   |

-----

<div style="border: 1px solid #ccc; padding: 10px; margin-top: 20px; border-radius: 5px;">
    <h3 style="margin-top: 0;">مرور سریع الگوهای طراحی</h3>
    <ul style="list-style: none; padding-left: 0;">
        <li><strong>Memento (یادگار)</strong>: ذخیره و بازیابی حالت داخلی یک شیء بدون نقض کپسوله‌سازی.<br><br></li>
        <li><strong>State (حالت)</strong>: به یک شیء اجازه می‌دهد وقتی حالت داخلی آن تغییر می‌کند، رفتارش را تغییر دهد.<br><br></li>
        <li><strong>Iterator (تکرارگر)</strong>: دسترسی ترتیبی به عناصر یک شیء مجموعه بدون افشای پیاده‌سازی داخلی آن.<br><br></li>
        <li><strong>Strategy (راهبرد)</strong>: تعریف خانواده‌ای از الگوریتم‌ها و کپسوله‌سازی هر یک، و امکان تعویض الگوریتم‌ها در زمان اجرا.<br><br></li>
        <li><strong>Template Method (متد قالب)</strong>: تعریف قالب الگوریتم در یک متد و اجازه به زیرکلاس‌ها برای ارائه پیاده‌سازی‌های خاص برای مراحل مشخص.<br><br></li>
        <li><strong>Command (فرمان)</strong>: درخواست‌ها را به عنوان اشیاء کپسوله می‌کند، و امکان پارامتری‌سازی، صف‌بندی و ثبت درخواست‌ها را فراهم می‌سازد.<br><br></li>
        <li><strong>Observer (ناظر)</strong>: ایجاد یک مکانیزم اعلان‌رسانی یک به چند بین اشیاء، به طوری که تغییر وضعیت یک شیء باعث اطلاع‌رسانی خودکار به وابسته‌ها شود.<br><br></li>
        <li><strong>Mediator (میانجی)</strong>: تعریف شیئی برای کپسوله‌سازی نحوه تعامل مجموعه‌ای از اشیاء، کاهش وابستگی مستقیم بین آن‌ها.<br><br></li>
        <li><strong>Chain Of Responsibility (زنجیره مسئولیت)</strong>: اجتناب از گره زدن فرستنده یک درخواست به گیرنده آن، و اجازه دادن به چندین شیء برای رسیدگی به درخواست.<br><br></li>
        <li><strong>Visitor (بازدیدکننده)</strong>: جدا کردن الگوریتم از ساختار شیئی که روی آن عمل می‌کند، افزودن عملیات جدید به ساختار شیء بدون تغییر کلاس‌ها.<br><br></li>
        <li><strong>Prototype (نمونه اولیه)</strong>: ایجاد اشیاء جدید با کپی کردن یک نمونه اولیه موجود.<br><br></li>
        <li><strong>Singleton (تک‌نسخه)</strong>: اطمینان از اینکه یک کلاس فقط یک نمونه دارد و یک نقطه دسترسی سراسری به آن فراهم می‌کند.<br><br></li>
        <li><strong>Factory Method (متد کارخانه)</strong>: تعریف یک رابط برای ایجاد اشیاء، اما واگذاری تصمیم‌گیری در مورد نوع شیء ایجاد شده به زیرکلاس‌ها.<br><br></li>
        <li><strong>Abstract Factory (کارخانه انتزاعی)</strong>: فراهم کردن یک رابط برای ایجاد خانواده‌ای از اشیاء مرتبط بدون مشخص کردن کلاس‌های مشخص آن‌ها.<br><br></li>
        <li><strong>Builder (سازنده)</strong>: جدا کردن ساخت شیء پیچیده از نمایش آن، امکان ساختن نمایش‌های مختلف از یک شیء.<br><br></li>
        <li><strong>Composite (ترکیبی)</strong>: ترکیب اشیاء به ساختارهای درختی برای نمایش سلسله مراتب جزء-کل.<br><br></li>
        <li><strong>Adaptor (مبدل)</strong>: تبدیل رابط یک کلاس به رابطی که کلاینت‌ها انتظار دارند، امکان همکاری کلاس‌هایی با رابط‌های ناسازگار.<br><br></li>
        <li><strong>Decorator (تزئین‌کننده)</strong>: اضافه کردن مسئولیت‌های جدید به یک شیء به صورت پویا.<br><br></li>
        <li><strong>Facade (نما)</strong>: فراهم کردن یک رابط یکپارچه برای یک مجموعه از رابط‌ها در یک زیرسیستم.<br><br></li>
        <li><strong>Fly Weight (مگس‌وزن)</strong>: استفاده از اشتراک‌گذاری برای پشتیبانی کارآمد از تعداد زیادی شیء کوچک.<br><br></li>
        <li><strong>Bridge (پل)</strong>: جدا کردن انتزاع از پیاده‌سازی، امکان تغییر مستقل آن‌ها.<br><br></li>
        <li><strong>Proxy (نماینده)</strong>: فراهم کردن یک جانشین یا نماینده برای کنترل دسترسی به یک شیء دیگر.<br><br></li>
    </ul>
</div>

